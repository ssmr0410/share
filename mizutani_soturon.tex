\documentclass{thesis}

\bibliographystyle{unsrt}

\input{jdummy.def}

\usepackage[dvipdfmx]{graphicx}

\usepackage{amsmath}			% math系
\usepackage{amssymb}			% math系
%\usepackage{float}				% 図表の挿入箇所を固定する[H]指定
\usepackage{cite}				% 参考文献
%\usepackage{url}				% 参考文献中のURL表記
\usepackage{algorithm}			% アルゴリズム環境
\usepackage{algpseudocode}      %アルゴリズム環境
%\usepackage[noend]{algpseudocode}  %ループやifのendがいらない時
\usepackage{listings}  			%アルゴリズム環境
\usepackage{comment}			% コメントアウト環境
\usepackage{bm}	%太字形式のベクトル

\headsep=1.4cm  %本文上にスペースを空けたい場合は 20mm にする

% 定理環境
\usepackage{amsthm}
\theoremstyle{definition}
\newtheorem{theorem}{定理}
\newtheorem{lemma}{補題}
\newtheorem{definition}{定義}
\newtheorem*{definition*}{定義}
\newtheorem{fact}{事実}
\newtheorem{corollary}{系}

% 先生コメント用
\usepackage[normalem]{ulem}
\usepackage{color}
\newcommand{\Izumi}[1]{\textcolor{blue}{#1}}
\newcommand{\Izurep}[2]{\textcolor{red}{\sout{#1}}{\Izumi{#2}}}

%%%%%%%% ここから本体 %%%%%%%%%%%%%%%%%%%%%%%%

\begin{document}
\baselineskip=22pt
\pagestyle{empty}

% タイトル
\gradyear{30}
\papertitle{タイトル}
\IDNumber{26115142}
\department{情報工学科}
\labo{泉研究室}
\enteryear{26}
\name{水谷　龍誠}
\maketitle

% 目次
\pagestyle{myheadings}	% ページ番号を右上につける
\pagenumbering{roman}	% ページ番号をローマ数字で
\tableofcontents

\newpage

% 本文
\pagenumbering{arabic}	% ページ番号をアラビア数字で

\chapter{はじめに}

\section{研究背景}

あるグラフ$G=(V,E)$が与えられたとき,グラフを非連結な二つの頂点集合に分割する小さな"セパレータ"の存在について考えられることがある.このセパレータの存在は,高速なグラフアルゴリズム設計において非常に重要である.
しかし,一般のグラフに対して最小サイズのセパレータを求める問題はNP困難であるため,小さなセパレータを求める近似アルゴリズムがこれまで研究されている.\par
現在,一般のグラフに対して小さなセパレータを近似する集中型のアルゴリズムはいくつか知られているが,分散環境におけるアルゴリズムはまだあまり知られていない.この論文では,既存の近似アルゴリズムをベースとする分散セパレータ近似アルゴリズムを提示する.

\section{研究結果}

\chapter{準備}
アルゴリズムは分散システムにおけるCONGESTモデルの下で動作する.$n$個の計算機ノード集合$V$と通信リンクの集合$E$である無向ネットワークグラフ$G=(V,E)$があるとする.CONGESTモデルにおいて計算機はラウンドに従って同期して動作を行う.各ラウンドにおいてノードは最大$O(\log n)$ビットのメッセージを各隣接ノードに送信,各隣接ノードからメッセージの受信,無制限の内部計算を行う事が出来る.\\
分散設定では,ノードは一意なID($O(\log n)$ビット)を持っており,隣接ノードのIDは知っているものとする.\par

グラフ$G=(V,E)$に対して,$D$はその直径を表すとする.頂点$s,t\in V$に対して,$s$と$t$を結ぶ経路をs-tパスと呼ぶ.特に,いくつかのs-tパスに対して,それぞれのパスが同じ頂点を共有しないとき,これらをs-t点素パスと呼ぶ.また,$s$と$t$の間にパスが存在しなくなるように取り除かれた頂点集合をs-tカットと呼ぶ.\par

s-t点素パスとカットについて以下の定理が示されている.

\begin{theorem}[メンガーの定理]
    グラフ$G$に対して,$s,t$のカットの最小値はs-t点素パスの最大本数と等しい
\end{theorem}

s-t点素パスの最大本数について考える.メンガーの定理によって各点素パスから頂点を一個づつ適切に取り出すと,その頂点集合はグラフ$G$の最小s-tカットになる.もちろん,任意に各パスから頂点を取り出すとs-tカットにならない場合もある.この各パスから任意に取り出した頂点集合を特にスライスと呼び,以下のように定義する.

\begin{definition}
    $G$をグラフとし,$s,t\in V$とする.$\{f_1, \dots ,f_k\}$を$G$における点素s-tパスの集合とする.
    この時,すべての$1\leq i\leq k$に対して,$w_i \in f_i$、$s \neq wi \neq t$であれば,$(f_1, \dots ,f_k)$に関してタプル$(w_1, \dots ,w_i)$をスライスと呼ぶ.
    XをVの任意の部分集合とし、$s,t \notin X$とする。$G[V\backslash X]$にs-tパスがない場合,$X$は$s$と$t$を分離すると言う。$s$と$t$を分離するスライスをカットと呼ぶ.
\end{definition}

スライスの集合は,$s$に対する相対的な"近さ"によって部分的に並べることができる.あるs-t点素パスの頂点について$s$方向を前方,$t$方向を後方として向きと順序を定義する.

\begin{definition}
    $\{f_1, \dots ,f_k\}$をs-t点素パスの集合とする.
    $U=(u_1, \dots, u_k)$および$W=(w_1, \dots ,w_k)$を$(f_1, \dots ,f_k)$に関するスライスとする.すべての$1\leq i\leq k$について、$u_i$は$f_i$における$w_i$の前方または$u_i=w_i$とする.この時$U$は$W$より$s$に近いと言い,$U\preceq W$と書く.$1 \leq i \leq k$に対して,さらに$u_i \neq w_i$ならば,$U$は$W$より厳密に$s$に近いと言い,$U \prec W$と書く.同様に、$W$は$U$より厳密に$t$に近いと言う.便宜上,タプル$(s,s, \dots ,s)$と$(t,t, \dots ,t)$についても同様に上記を定義.したがって,例えば,$(s,s,...s)$はどのスライスよりも$s$に近いと言える.$"\preceq"$は一般的な順序の合計を定義するものではない.
\end{definition}

カットを取り除くことでは$G$を少なくとも2つの連結成分に分離する.
あるカットによって分離した各連結成分に対して以下の定義をする.

\begin{definition}
    $U$を任意のカットとする.$s$を含む$G[V\backslash U]$の連結成分の頂点セットとして$V_s(U)$を定義し,$t$を含む$G [V\backslash U]$の連結成分の頂点セットとして$V_t(U)$を定義し,$V_r$を$G [V \backslash U]$の残りの連結成分の頂点集合の和集合として定義する.すなわち、$V_r(U)$は$ｓ$も$ｔ$も含まない連結成分である.（したがって、$V_r(u)$は空であり得る）
\end{definition}

\section{セパレータ}
頂点集合$V$の分割$(A,S,B):V=A \cup S \cup B$について,$|A|\leq \frac{2}{3}|V|$かつ$|B|\leq \frac{2}{3}|V|$であり,集合$A,B$間に辺が存在しないとき,集合$S$を$G$のセパレータと呼ぶ.$0 <\alpha < 1$とし,上記の分割$(A,S,B)$に対して$|A|,|B|\leq \alpha|V|$の時,$S$を$\alpha$-セパレータと呼ぶ.\par
セパレータ,またはカットはある値$\alpha$に関して,セパレータやカットによって分割された全ての頂点集合のサイズが高々$\alpha |V|$以下である時,セパレータやカットについてバランスが取れていると言うことにする.

\section{Subgraph Aggregation}
GhaffariとHaeupler\cite{ghaffari2016distributed}のショートカットフレームワークは,制限されたグラフ族の分散アルゴリズムを設計する上で有益であることが証明されて
いる.さらに,このショートカットフレームワークの制約をさらに弱めて改良されたタスクがJason\cite{li2018distributed}によって示されている.
この論文では,このショートカットのフレームワークの内部動作には触れずにSubgraph Aggregationとして定義されているタスクを利用する.

\begin{definition}[Subgraph Aggregation\cite{li2018distributed}\cite{haeupler2018round}]
    $G=(V,E)$をネットワークグラフとし,$\mathcal{P} =(P_1,...P_{|\mathcal{P}|})$をパートの集合,各$P_i$について$H_i$を$P_i$のノード上のGの連結部分グラフとする.必ずしもグラフ$G[P_i]$から誘導されるとは限らない.各部分グラフ$H_i$について、$V(H_i)$内のすべてのノードが部分グラフ$H_i$内の隣接ノードを認識し、それ以外は何も知らないと仮定する.すべてのノード$v\in \bigcup_iP_i$がO(log n)ビットの整数$x_v$を持ち,$\oplus$を長さO（log n）の整数に作用する結合関数とする.$P_i$内の各ノードは値$\bigoplus_{v\in P_i}x_v$、すなわち$P_i$内のすべての値$x_v$の集合$\oplus$を知りたいとする.このようなタスクをオペレーター$\oplus$におけるSubgraph Aggregationと呼ぶ.
\end{definition}

SAラウンドを,Subgraph Aggregation（SA）において各パートがその収集値$\bigoplus$を学習する一回の反復とする.SAは特別なグラフ構造に関して以下の定理が成り立つ.

\begin{theorem} \label{SA}
    結合演算子$\oplus$について、$Q_G$がグラフ$G$とその直径$D$に依存するパラメータである場合,$\tilde{O}(Q_G)$ラウンドでSubgraph Aggregation問題を解くことができる.
    \item 全てのグラフ$G:Q_G = O(\sqrt{n}+D)$
    \item 種数$g$のグラフ$G:Q_G=O(\sqrt{g+1}D)$
    \item 木幅$k$のグラフ$G:Q_G=\tilde{O}(kD)$
    \item $H$をマイナーとして含まないグラフ$G:Q_G=\tilde{O}(f(H)\cdot D^2)$,$f$は$H$にのみ依存する関数
\end{theorem}

\section{s-t点素パス探索アルゴリズム}
グラフプロパティの一種である木幅と呼ばれる値$k$に対して以下の補題が示されている.

\begin{lemma}[\cite{li2018distributed}]
    木幅が高々$k$のグラフ$G=(V,E)$と二つの頂点$s,t\subseteq V$を与えると,$k$点素s-tパスを見つけるか,サイズ$k$以下のs-tノードカットを$\tilde{O}(k^{O(1)}D)$ラウンドで出力する分散アルゴリズムが存在する.前者の場合,各ノードは自身がパス上にあるかどうかを知っており、そうであれば、そのパス上のその前方と後方を知る.後者の場合、$k$点素パスが存在しないという事実と,カットに含まれるかどうかを各ノードが知っている.
\end{lemma}

 アルゴリズムの詳細については触れないが,点素パスの探索ステップ自体には木幅の値は関わっていない.木幅が影響するのはSAラウンドに関してのみである.上記の補題と定理\ref{SA}より一般のグラフに置き換えた以下の系が成り立つ.

\begin{corollary}
    補題1のグラフ$G$を一般のグラフに置き換えると,最大$\ell$本のs-t点素パスは$\tilde{O}(\ell^{O(1)}(\sqrt{n}+D))$ラウンドで見つけることができる.
\end{corollary}

\chapter{既存手法の概要}

既存の近似アルゴリズム\cite{brandt2017approximating}のプロセスを簡略化して説明する.\\

アルゴリズムのアプローチは最大s-tフローに基づいている.
小さいセパレータを含むグラフ$G$が与えられ,そのセパレータの「異なる側に」頂点$s$と$t$があるとする.この時,メンガーの定理により,s-t点素パスの最大数も少なくなる.\par
アルゴリズムはs-t点素パスの最大本数の集合を計算することから始める.
最大本数$k$本の各パスから１つの頂点を取ることによって,$k$個のs−tカットを見つける.これらの頂点はsとtを分離するように選ぶ必要がある.s-tカットは,メンガーの定理によって存在することは明らかである.\par

次に,二分探索法を使用して,全てのs−tカットのうち1つは$s$に近く,もう1つは$t$に近い２つの「最良のバランス」を決定する.これら2つのカットのうちの1つが十分にバランスが取れていれば,目的の小さいセパレータが発見できたことになる.バランスが取れていないとき,連結成分が2つのs-tカットで分断されているされていると見なす.そして,$s$を含む連結成分を新たな頂点$s'$に,$t$を含む成分を新たな頂点$t'$に縮約する.
新しく得られたグラフのすべての$s'$-$t'$頂点カットも$G$のs-tカットであり,さらに上記の2つのs-tカットよりもバランスが取れていることが示されている.そのため,本数がある値$K$に等しいs-tカットを得るまで点素パスを探索,最良のバランスのとれたs-tカットをいくつか発見し,頂点集合を縮約する上記のプロセスを繰り返す.\par

$\frac{2}{3} \leq \alpha < 1$の時、$s$と$t$を分離する最大で$K$のサイズの$\alpha$-セパレータの存在を考える.上述した反復プロセス終了時,バランスが少なくとも$\alpha$と同等であるカットを生じない場合,$\alpha$-セパレータの少なくとも１つの頂点が実行された縮約のうちの１つに関与しているとみなす.したがって,プロセス全体を最大$K$回反復することによって,（プロセスで得られたすべての関連カットを集めることによって）セパレータを探索する.\par

ここまで,セパレータの「異なる側にある」頂点$s$と$t$を見つけることができると仮定していたが,実際には$s$と$t$を一様ランダムに選択している為,上記の反復プロセスを適用してから得られた最大の連結成分に対して再度縮約アルゴリズムを反復する.\par
このようにして,与えられたグラフが小さいセパレータを含んでいれば,小さいセパレータを見つけるためのほぼ線形の実行時間を得る.\par

上記のプロセスをまとめると,ある値$\frac{2}{3} \leq \alpha <$と$0 < \varepsilon <1-\alpha$について以下の結果が示される.\\
グラフ$G=(V,E),n \in V,m \in E$について,$G$がサイズ$K$の$\alpha$-セパレータを含んでいるとき,アルゴリズムはサイズ$O(\varepsilon^{-1} K^2 \log^{1+o(1)}n)$の$(\alpha + \varepsilon)$-セパレータを高確率で$O(\varepsilon^{-1}K^3m\log^{2+o(1)}n)$時間で見つけることができる.

\chapter{分散実装}
このセクションでは,セパレータを近似するための分散アルゴリズムを提示する.
具体的には,\cite{brandt2017approximating}の5つのアルゴリズムそれぞれを分散ネットワークで実行できるように適応させていく.

\section{カット探索}
あるスライスが与えられた時,そのスライスに近いカットについて定義する.

\begin{definition}
    $(f_1, \dots ,f_k)$に関してUをスライスとする.
    $U\preceq X$であり,かつ$U\preceq X'\prec X$を満たすカット$X'$が存在しないようなカットを$X$とする.この時$U^+:=X$を定義する.\\
    上記のような$X$が存在しない場合は、$U^+:=(t,t,\dots,t)$とする.\\
    同様に,$Y\preceq U$かつ$U\preceq Y'\prec Y$を満たすカット$Y'$が存在しないようなカットを$Y$とする.この時,$U^-:=Y$を定義する.\\
    上記のような$Y$が存在しない場合は$U^-:=(s,s,\dots,s)$とする. 
\end{definition}

上記のカット$U^+,U^-$を計算するアルゴリズムを以下に示す.\par

\begin{enumerate}
    \item 点素パス上の各頂点が隣接頂点にパス上のインデックスをブロードキャスト
    \item 各点素パスの頂点を含まない$G$の各連結成分内(仮$C$)で,受け取ったパスのインデックスの最大値最小値を収集(2kSAラウンド)
    \item スライス$U$のインデックスを各点素パス上のノードが知る(kSAラウンド)
    \item パス上の各頂点がスライス$U$のインデックスを隣接頂点にブロードキャスト(kラウンド)
    \item 各$C$内の頂点が点素パスの情報を2つ以上知っているとき
    \begin{itemize}
      \item 各$C$内で受け取ったスライスのインデックスと大小比較
      \item どれか一つでもスライスのインデックスより小さい時,$C$を$X$に追加
      \item $X$内でパスの最大値を収集(kSAラウンド)
    \end{itemize}
    \item loop 一番長い点素パスの長さ$\ell$分だけ繰り返す可能性
    \item 収集したインデックスの最大値(仮$w_i$)の1つ前までのパスの頂点を$X$に追加
    \item 最小値が$x_i$より小さい$C$を$X$に追加
    \item 最大値収集,$w_i$を更新
  \end{enumerate}
全体で$\ell k$SAラウンド

\section{縮約アルゴリズム}
縮約ステップでは,,まず初めに与えられた$s,t\in V$

\chapter{まとめと今後の課題}

\chapter{謝辞}
本研究の機会を与え，数々の御指導を賜りました泉泰介准教授に深く感謝致します．また，本研究を進めるにあたり多くの助言を頂き，様々な御協力を頂きました泉研究室の学生の皆様に深く感謝致します．

% 参考文献
\nocite{*}
\bibliography{mizutani_references}

% 付録
%\include{appendix}

\end{document}
