\documentclass{thesis}

\bibliographystyle{unsrt}

\input{jdummy.def}

\usepackage[dvipdfmx]{graphicx}

\usepackage{amsmath}			% math系
\usepackage{amssymb}			% math系
\usepackage{float}				% 図表の挿入箇所を固定する[H]指定
\usepackage{cite}				% 参考文献
%\usepackage{url}				% 参考文献中のURL表記
\usepackage{algorithm}			% アルゴリズム環境
\usepackage{algpseudocode}      %アルゴリズム環境
%\usepackage[noend]{algpseudocode}  %ループやifのendがいらない時
\usepackage{listings}  			%アルゴリズム環境

\let\thealgorithm\relax %タイトル番号非表示

\usepackage{comment}			% コメントアウト環境
\usepackage{bm}	%太字形式のベクトル

\headsep=1.4cm  %本文上にスペースを空けたい場合は 20mm にする

% 定理環境
\usepackage{amsthm}
\theoremstyle{definition}
\newtheorem{theorem}{定理}
\newtheorem{lemma}{補題}
\newtheorem{definition}{定義}
\newtheorem*{definition*}{定義}
\newtheorem{fact}{事実}
\newtheorem{corollary}{系}

% 先生コメント用
\usepackage[normalem]{ulem}
\usepackage{color}
\newcommand{\Izumi}[1]{\textcolor{blue}{#1}}
\newcommand{\Izurep}[2]{\textcolor{red}{\sout{#1}}{\Izumi{#2}}}

%%%%%%%% ここから本体 %%%%%%%%%%%%%%%%%%%%%%%%

\begin{document}
\baselineskip=22pt
\pagestyle{empty}

% タイトル
\gradyear{30}
\papertitle{平衡分離集合を近似する分散アルゴリズム}
\IDNumber{26115142}
\department{情報工学科}
\labo{泉研究室}
\enteryear{26}
\name{水谷　龍誠}
\maketitle

% 目次
\pagestyle{myheadings}	% ページ番号を右上につける
\pagenumbering{roman}	% ページ番号をローマ数字で
\tableofcontents

\newpage

% 本文
\pagenumbering{arabic}	% ページ番号をアラビア数字で

\chapter{はじめに}

\section{研究背景}

あるグラフ$G=(V,E)$が与えられたとき,グラフを非連結な二つの頂点集合に分割する小さな"セパレータ"の存在について考えられることがある.このセパレータの存在は,高速なグラフアルゴリズム設計において非常に重要である.
しかし,一般のグラフに対して最小サイズのセパレータを求める問題はNP困難であるため,小さなセパレータを求める近似アルゴリズムがこれまで研究されている.\par
現在,一般のグラフに対して小さなセパレータを近似する集中型のアルゴリズムはいくつか知られているが,分散環境におけるアルゴリズムはまだあまり知られていない.この論文では,BrandtとWattenhoferの近似アルゴリズム\cite{brandt2017approximating}をベースとする分散セパレータ近似アルゴリズムを提示する.

\section{論文構成}
本論文は全5章で構成される.2章ではアルゴリズムのために必要な諸定義や補題等の準備.3章では既存の集中型でのアルゴリズムの概要説明.4章では分散セパレータ近似アルゴリズムの提示.5章で研究のまとめを記述する.

\chapter{準備}
アルゴリズムは分散システムにおけるCONGESTモデルの下で動作する.$n$個の計算機ノード集合$V$と通信リンクの集合$E$である無向ネットワークグラフ$G=(V,E)$があるとする.CONGESTモデルにおいて計算機はラウンドに従って同期して動作を行う.各ラウンドにおいてノードは最大$O(\log n)$ビットのメッセージを各隣接ノードに送信,各隣接ノードからメッセージの受信,無制限の内部計算を行う事が出来る.\\
分散設定では,ノードは一意なID($O(\log n)$ビット)を持っており,隣接ノードのIDは知っているものとする.\par

グラフ$G=(V,E)$に対して,$D$はその直径を表すとする.頂点$s,t\in V$に対して,$s$と$t$を結ぶ経路をs-tパスと呼ぶ.特に,いくつかのs-tパスに対して,それぞれのパスが同じ頂点を共有しないとき,これらをs-t点素パスと呼ぶ.また,$s$と$t$の間にパスが存在しなくなるように取り除かれた頂点集合をs-tカットと呼ぶ.\par

s-t点素パスとカットについて以下の定理が示されている.

\begin{theorem}[メンガーの定理]
    グラフ$G$に対して,$s,t$のカットの最小値はs-t点素パスの最大本数と等しい
\end{theorem}

s-t点素パスの最大本数について考える.メンガーの定理によって各点素パスから頂点を一個づつ適切に取り出すと,その頂点集合はグラフ$G$の最小s-tカットになる.もちろん,任意に各パスから頂点を取り出すとs-tカットにならない場合もある.この各パスから任意に取り出した頂点集合を特にスライスと呼び,以下のように定義する.

\begin{definition}
    $G$をグラフとし,$s,t\in V$とする.$\{f_1, \dots ,f_k\}$を$G$における点素s-tパスの集合とする.
    この時,すべての$1\leq i\leq k$に対して,$w_i \in f_i$、$s \neq wi \neq t$であれば,$(f_1, \dots ,f_k)$に関してタプル$(w_1, \dots ,w_i)$をスライスと呼ぶ.
    XをVの任意の部分集合とし、$s,t \notin X$とする。$G[V\backslash X]$にs-tパスがない場合,$X$は$s$と$t$を分離すると言う。$s$と$t$を分離するスライスをカットと呼ぶ.
\end{definition}

スライスの集合は,$s$に対する相対的な"近さ"によって部分的に並べることができる.あるs-t点素パスの頂点について$s$方向を前方,$t$方向を後方として向きと順序を定義する.

\begin{definition}
    $\{f_1, \dots ,f_k\}$をs-t点素パスの集合とする.
    $U=(u_1, \dots, u_k)$および$W=(w_1, \dots ,w_k)$を$(f_1, \dots ,f_k)$に関するスライスとする.すべての$1\leq i\leq k$について、$u_i$は$f_i$における$w_i$の前方または$u_i=w_i$とする.この時$U$は$W$より$s$に近いと言い,$U\preceq W$と書く.$1 \leq i \leq k$に対して,さらに$u_i \neq w_i$ならば,$U$は$W$より厳密に$s$に近いと言い,$U \prec W$と書く.同様に、$W$は$U$より厳密に$t$に近いと言う.便宜上,タプル$(s,s, \dots ,s)$と$(t,t, \dots ,t)$についても同様に上記を定義.したがって,例えば,$(s,s,...s)$はどのスライスよりも$s$に近いと言える.$"\preceq"$は一般的な順序の合計を定義するものではない.
\end{definition}

カットを取り除くことでは$G$を少なくとも2つの連結成分に分離する.
あるカットによって分離した各連結成分に対して以下の定義をする.

\begin{definition}
    $U$を任意のカットとする.$s$を含む$G[V\backslash U]$の連結成分の頂点セットとして$V_s(U)$を定義し,$t$を含む$G [V\backslash U]$の連結成分の頂点セットとして$V_t(U)$を定義し,$V_r$を$G [V \backslash U]$の残りの連結成分の頂点集合の和集合として定義する.すなわち、$V_r(U)$は$ｓ$も$ｔ$も含まない連結成分である.（したがって、$V_r(u)$は空であり得る）
\end{definition}

\section{セパレータ}
頂点集合$V$の分割$(A,S,B):V=A \cup S \cup B$について,$|A|\leq \frac{2}{3}|V|$かつ$|B|\leq \frac{2}{3}|V|$であり,集合$A,B$間に辺が存在しないとき,集合$S$を$G$のセパレータと呼ぶ.$\frac{2}{3} \leq \alpha < 1$とし,上記の分割$(A,S,B)$に対して$|A|,|B|\leq \alpha|V|$の時,$S$を$\alpha$-セパレータと呼ぶ.\par
セパレータ,またはカットはある値$\alpha$に関して,セパレータやカットによって分割された全ての頂点集合のサイズが高々$\alpha |V|$以下である時,セパレータやカットについてバランスが取れていると言うことにする.

\section{Subgraph Aggregation}
GhaffariとHaeupler\cite{ghaffari2016distributed}のショートカットフレームワークは,制限されたグラフ族の分散アルゴリズムを設計する上で有益であることが証明されて
いる.さらに,このショートカットフレームワークの制約をさらに弱めて改良されたタスクがLi\cite{li2018distributed}によって示されている.
この論文では,このショートカットのフレームワークの内部動作には触れずにSubgraph Aggregationとして定義されているタスクを利用する.

\begin{definition}[Subgraph Aggregation\cite{li2018distributed}\cite{haeupler2018round}]
    $G=(V,E)$をネットワークグラフとし,$\mathcal{P} =(P_1,...P_{|\mathcal{P}|})$をパートの集合,各$P_i$について$H_i$を$P_i$のノード上のGの連結部分グラフとする.必ずしもグラフ$G[P_i]$から誘導されるとは限らない.各部分グラフ$H_i$について、$V(H_i)$内のすべてのノードが部分グラフ$H_i$内の隣接ノードを認識し、それ以外は何も知らないと仮定する.すべてのノード$v\in \bigcup_iP_i$がO(log n)ビットの整数$x_v$を持ち,$\oplus$を長さO（log n）の整数に作用する結合関数とする.$P_i$内の各ノードは値$\bigoplus_{v\in P_i}x_v$、すなわち$P_i$内のすべての値$x_v$の集合$\oplus$を知りたいとする.このようなタスクをオペレーター$\oplus$におけるSubgraph Aggregationと呼ぶ.
\end{definition}

SAラウンドを,Subgraph Aggregation（SA）において各パートがその収集値$\bigoplus$を学習する一回の反復とする.SAは特別なグラフ構造に関して以下の定理が成り立つ.

\begin{theorem} \label{SA}
    結合演算子$\oplus$について、$Q_G$がグラフ$G$とその直径$D$に依存するパラメータである場合,$\tilde{O}(Q_G)$ラウンドでSubgraph Aggregation問題を解くことができる.
    \item 全てのグラフ$G:Q_G = O(\sqrt{n}+D)$
    \item 種数$g$のグラフ$G:Q_G=O(\sqrt{g+1}D)$
    \item 木幅$k$のグラフ$G:Q_G=\tilde{O}(kD)$
    \item $H$をマイナーとして含まないグラフ$G:Q_G=\tilde{O}(f(H)\cdot D^2)$,$f$は$H$にのみ依存する関数
\end{theorem}


\section{s-t点素パス探索アルゴリズム}
グラフプロパティの一種である木幅と呼ばれる値$k$に対して以下の補題が示されている.

\begin{lemma}[\cite{li2018distributed}] \label{path}
    木幅が高々$k$のグラフ$G=(V,E)$と二つの頂点$s,t\subseteq V$を与えると,$k$点素s-tパスを見つけるか,サイズ$k$以下のs-tノードカットを$\tilde{O}(k^{O(1)}D)$ラウンドで出力する分散アルゴリズムが存在する.前者の場合,各ノードは自身がパス上にあるかどうかを知っており、そうであれば、そのパス上のその前方と後方を知る.後者の場合、$k$点素パスが存在しないという事実と,カットに含まれるかどうかを各ノードが知っている.
\end{lemma}

 アルゴリズムの詳細については触れないが,点素パスの探索ステップ自体には木幅の値は関わっていない.木幅が影響するのはSAラウンドに関してのみである.上記の補題と定理\ref{SA}より一般のグラフに置き換えた以下の系が成り立つ.

\begin{corollary}
    補題\ref{path}のグラフ$G$を一般のグラフに置き換えると,最大$k$本のs-t点素パスは$\tilde{O}(k^{O(1)}(\sqrt{n}+D))$ラウンドで見つけることができる.終了時,すべての頂点は自身がパス上にあるかどうか,そしてもし存在すればそのパスの前方と後方を知っている.
\end{corollary}

また,\cite{li2018distributed}では以下の系が示されている.

\begin{corollary}[\cite{li2018distributed}] \label{A-Bpath}
    木幅$k$のグラフ$G =(V,E)$で,$G[U]$が連結であるような集合$U \subseteq V$およ
    び3つの互いに素な頂点集合$A,B \subseteq V - U$および$X \subseteq U$を考えると,$\tilde{O}(k^{O(1)}D)$ラウンドで内部ノードが$G[U] - X$に属する$k$個の$A$-$B$点素パスを見つけることができるか,$k$個の点素パスは存在しないと結
    論付ける.前者の場合,すべての頂点は自身がパス上にあるかどうか,そし
    てもし存在すればそのパスの前と後を知っています.後者の場合,全ての頂
    点は,$k$個の点素パスが存在しないという事実を知っている.
\end{corollary}

この系についても,先程と同様にして以下のように修正する.

\begin{corollary}
    系\ref{A-Bpath}のグラフを一般のグラフ$G =(V,E)$に置き換える.$G[U]$が連結であるような集合$U \subseteq V$および3つの互いに素な頂点集合$A,B \subseteq V - U$および$X \subseteq U$を考えると,$\tilde{O}(k^{O(1)}(\sqrt{n}+D))$ラウンドで内部ノードが$G[U] - X$に属する最大$k$本の$A$-$B$点素パスを見つけることができる.終了時,すべての頂点は自身がパス上にあるかどうか,そしてもし存在すればそのパスの前方と後方を知っている.
\end{corollary}


\chapter{既存手法の概要}

この章では,BrandtとWattenhoferの近似アルゴリズム\cite{brandt2017approximating}のプロセスを簡略化して説明する.\\

アルゴリズムのアプローチは最大s-tフローに基づいている.
小さいセパレータを含むグラフ$G$が与えられ,そのセパレータを跨ぐ"異なる側"に頂点$s$と$t$があるとする.この時,メンガーの定理により,s-t点素パスの最大数も少なくなる.\par
アルゴリズムはs-t点素パスの最大本数の集合を計算することから始める.
最大本数$k$本の各パスから１つの頂点を取ることによって,$k$個のs-tカットを見つける.これらの頂点はsとtを分離するように選ぶ必要がある.s-tカットは,メンガーの定理によって存在することは明らかである.\par

次に,二分探索法により全てのs-tカットの中でバランスがとれた2つのカットを決定する.これら2つのカットのうちの1つが元のグラフに対しても十分にバランスが取れていれば,目的の小さいセパレータが発見できたことになる.バランスが取れていないとき,連結成分が2つのs-tカットで分断されているされていると見なす.そして,$s$を含む連結成分を新たな頂点$s'$に,$t$を含む成分を新たな頂点$t'$に縮約する.
新しく得られたグラフのすべての$s'$-$t'$頂点カットも$G$のs-tカットであり,さらに上記の2つのs-tカットよりもバランスが取れていることが示されている.そのため,本数がある値$K$に等しいs-tカットを得るまで点素パスを探索し,最良のバランスのとれたs-tカットをいくつか発見し,頂点集合を縮約する上記のプロセスを繰り返す.\par

$\frac{2}{3} \leq \alpha < 1$の時、$s$と$t$を分離する最大で$K$のサイズの$\alpha$-セパレータの存在を考える.上述した反復プロセス終了時,バランスが少なくとも$\alpha$と同等であるカットを生じない場合,$\alpha$-セパレータの少なくとも１つの頂点が実行された縮約のうちの１つに関与しているとみなす.したがって,プロセス全体を反復することによって,セパレータを探索する.\\
ここまで,セパレータの「異なる側にある」頂点$s$と$t$を見つけることができると仮定していたが,実際には$s$と$t$を一様ランダムに選択している為,上記の反復プロセスを適用してから得られた最大の連結成分に対して再度縮約アルゴリズムを反復する.\\
このようにして,与えられたグラフが小さいセパレータを含んでいれば,小さいセパレータを見つけるためのほぼ線形の実行時間を得る.\par

上記のプロセスをまとめると,ある値$\frac{2}{3} \leq \alpha <$と$0 < \varepsilon <1-\alpha$について以下の結果が示される.\\
グラフ$G=(V,E),n \in V,m \in E$について,$G$がサイズ$K$の$\alpha$-セパレータを含んでいるとき,アルゴリズムはサイズ$O(\varepsilon^{-1} K^2 \log^{1+o(1)}n)$の$(\alpha + \varepsilon)$-セパレータを高確率で$O(\varepsilon^{-1}K^3m\log^{2+o(1)}n)$時間で見つけることができる.

\chapter{分散実装}
この章では,セパレータを近似するための分散アルゴリズムを提示する.
具体的には,\cite{brandt2017approximating}の5つのアルゴリズムそれぞれを分散ネットワークで実行できるように適応させていく.

\section{カット探索アルゴリズム}
あるスライスが与えられた時,そのスライスに"近い"カットについて定義する.

\begin{definition}
    $(f_1, \dots ,f_k)$に関してUをスライスとする.
    $U\preceq X$であり,かつ$U\preceq X'\prec X$を満たすカット$X'$が存在しないようなカットを$X$とする.この時$U^+:=X$を定義する.\\
    上記のような$X$が存在しない場合は、$U^+:=(t,t,\dots,t)$とする.\\
    同様に,$Y\preceq U$かつ$U\preceq Y'\prec Y$を満たすカット$Y'$が存在しないようなカットを$Y$とする.この時,$U^-:=Y$を定義する.\\
    上記のような$Y$が存在しない場合は$U^-:=(s,s,\dots,s)$とする. 
\end{definition}

上記のカット$U^+$を求めるアルゴリズムを以下に示す.\\
s-t点素パスは計算済みであり,点素パスの最大本数$k$とする.パス上の各ノードは自身が点素パスの要素であることと,パス上の順序によるインデックスを知っているとする.\par
まず,点素パス上の各ノードが隣接ノードに対してパス上でのインデックスをブロードキャストする.$G$から点素パスの要素を除くことで得られる各連結成分を$B$とし,各$B$内で受け取ったパスのインデックスの最大値を収集する.$B$内のブロードキャストを受け取った各ノードは,ブロードキャストを行わなかった隣接ノードが$B$内のノードであると認識できるため,SAによって通信することができる.最大$k$本のパスに対する最大値を収集するので,高々$k$SAラウンドで収集完了する.\\
次に,スライス$U$よりも前方にあるパス上のノードは,あるノード集合$X$を示すIDをセットし,スライス$U$を除く隣接ノードにID($X$)をブロードキャストする.ID($X$)を受け取った$B$を$X$の部分集合とする.\\
以降,$X$に$B$を追加し,$X$内で各パスの最大インデックス値を収集.最大値が更新されたとき,そのインデックスを持つノードよりも前方にあるノードを$X$に追加して,隣接ノードにID($X$)をブロードキャストして$B$を$X$に追加して再度最大値を収集する反復を,最大値が更新されなくなるまで繰り返す.$X$内での最大値収集は$k$SAラウンドで完了する.\par
反復終了後,最終的な各パスの最大値が求める$U^+$である.また,終了後のノード集合$x$は$V_s(U^+)$,隣接ノードが$U^+$のみである各$B$は$V_r(U^+)$,それ以外のノードは$V_t(U^+)$である.\par
反復回数は,最悪ケースの場合最も長いパスの長さ分だけ繰り返される.このパスの長さを$\ell$とするとアルゴリズムは$O(\ell k)$SAラウンドで終了する.$U^-$の計算は,$U^+$のアルゴリズムの前方後方を入れ替えることで同様に計算できる.

\section{縮約アルゴリズム}


まず系\ref{path}を使用して最大本数$k$本のs-t点素パス集合$\{f_1, \dots f_k\}$を求める.求めた点素パス上の各ノードは,以下に示す補題によりパス上での順序に関するインデックスや前後方の収集値を$O(\log n)$SAラウンドで知ることができる.

\begin{lemma}[経路収集\cite{li2018distributed}]
    $G$の有向パス$P = \{v_1,...,v_\ell\}$を考える.ここで、各ノード$v_i$はそのパスの前方ノードと後方ノードを知っている.$O(\log n)$SAラウンドにおいて,各ノード$v_i$は$i$の値と経路内のそのインデックスを知ることができる.さらに,各ノード$v_i$が整数$x_i$と共通の結合演算子$\oplus$を知っていれば、各ノード$v_i$に先頭集約$\bigoplus_{j\leq i}xj$と後尾集約$\bigoplus_{j\geq i}x_j$を学習させることができる.
  \end{lemma}

次に,最良のカット候補である$S,T$を二分探索によって求める.$g(s),g(t)$を,縮約する集合の要素数とする.以下に\cite{brandt2017approximating}の探索アルゴリズムを提示する.

\begin{algorithm}[H]
    \caption{最良のカット候補$S$} 
    \textbf{初期設定:} \par
    $g(s),g(t)\in \mathbb{N}$ \\
    s-t点素パス$f_1,...,f_k$ \\
    $\ell_i:f_i$の長さ($(s)$は0番目) \\
    $v_{ij},0 \leq j \leq \ell_i$を$f_i$上の$j$番目の頂点とする \\
    $w_i=v_{i1}(1\leq i \leq k)$ \\
    valid := \textbf{false} \\
    {\setlength{\baselineskip}{12pt}
    \begin{algorithmic}[1]
      \For {$i=1$ to $k$}
        \State {$c:=0$} \Comment {$f_i$の始まり}
        \State {$d:=\ell_i$} \Comment {$f_i$の終わり}
        \While {$d \neq c+1$}
            \State {$e:= \lceil \frac{c+d}{2} \rceil$} \Comment {$f_i$二分探索}
            \State {$W:=w_1,...,w_{i-1},v_{ie},w_{i+1},...,w_k$} \Comment {$i$番目を動かす}
            \If {$W^+\neq (t,t,...,t)$and$|V_s(W^+)+g(s)\leq |V_r(W^+)\cup V_t(W^+)|+g(t)$} 
            \State {$c:=e$} 
            \State {valid $:=$ \textbf{true}}
            \Else
            \State {$d:=e$}
            \EndIf　
        \EndWhile　\Comment {$O(\log n)$回反復}
      \State {$w_i:=v_{ic}$}
      \EndFor
      \If {vaild}
      \State {\textbf{return}} $(w_1,...,w_k)$
      \Else
      \State {\textbf{return}} $(s,s,...,s)$
      \EndIf
    \end{algorithmic}
    }
\end{algorithm}

\begin{algorithm}[H]
  \caption{最良のカット候補$T$} 
  \textbf{初期設定:} \\
  $g(s),g(t)\in \mathbb{N}$ \\
  s-t点素パス$f_1,...,f_k$ \\
  $\ell_i:f_i$の長さ($(s)$は0番目) \\
  $v_{ij},0 \leq j \leq \ell_i$を$f_i$上の$j$番目の頂点とする \\
  $w_i=v_{i1}(1\leq i \leq k)$ \\
  valid := \textbf{false} \\ 
  {\setlength{\baselineskip}{12pt}
  \begin{algorithmic}[1]
    \For {$i=1$ to $k$}
      \State {$c:=0$} \Comment {$f_i$の始まり}
      \State {$d:=\ell_i$} \Comment {$f_i$の終わり}
      \While {$d \neq c+1$}
          \State {$e:= \lfloor \frac{c+d}{2} \rfloor$} \Comment {$f_i$二分探索}
          \State {$W:=w_1,...,w_{i-1},v_{ie},w_{i+1},...,w_k$} \Comment {$i$番目を動かす}
          \If {$W^-\neq (t,t,...,t)$and$|V_t(W^-)+g(t)\leq |V_r(W^-)\cup V_s(W^-)|+g(s)$} 
          \State {$d:=e$} 
          \State {vaild $:=$ \textbf{true}}
          \Else
          \State {$c:=e$}
          \EndIf　
          \EndWhile　\Comment {$O(\log n)$回反復}
    \State {$w_i:=v_{id}$}
    \EndFor
    \If {vaild}
    \State {\textbf{return} $(w_1,...,w_k)$}   
    \Else
    \State {\textbf{return}} $(s,s,...,s)$
    \EndIf
  \end{algorithmic}
  }
\end{algorithm}

それぞれのwhileの反復は,$f_i$を二分探索する反復なので$O(\log n)$回で終了する.前節で示した$U^+,U^-$の結果と合わせて,$S,T$はそれぞれ$O(\ell k^2 \log n)$SAラウンドで計算できる.\par
カット$S,T$に対し,$M_s = V_s(S) \cup S,M_t = V_t(W) \cup W$とする.$V_s(S),V_t(T)$は$U^+,U^-$の計算時に同時に求めてある.$M_s \cap M_t \neq \emptyset $または$M_s,M_t$間に辺がある時,結果をこの時の$S,T$として縮約アルゴリズムは終了する.この判定は$S,T$の各ノードが隣接ノードに各集合のIDをブロードキャストすることで判定できる.\\
そうでなければ,$M_s,M_t$をそれぞれ単一のノード$s,t$に縮約したとみなして反復を繰り返す.これは,系\ref{A-Bpath}によって$M_s,M_t$間の点素パスを求めることが可能であるため,問題なく実行することができる.\par
縮約アルゴリズムは,最大$K$回反復するので,アルゴリズムは$\tilde{O}(K^2(K^{O(1))}+\ell)(\sqrt{n}+D)$ラウンドで終了する.


\section{近似アルゴリズム}
これまでのアルゴリズムを適用してセパレータ近似アルゴリズムを提示する.このアルゴリズムは,縮約アルゴリズムを適用して得られたカットによってグラフ$G$を分割し,分割後の各連結成分の中で一番ノード数が多い連結成分を$H$として縮約アルゴリズムを繰り返し適用する.縮約アルゴリズムによって得られたカットについてバランスが取れているとき, 反復は終了する.反復終了後,各反復で得られたカットと$s,t$の和集合が求めたい近似セパレータとなる.\par
まず,$\frac{2}{3} \leq \alpha < 1,0 < \varepsilon < 1-\alpha$とし,$G$にサイズ$K$の$\alpha$-セパレータが存在すると仮定する.初期インスタンス$H:=G,S':= \{\}$とする.$S'$が最終的に求める近似セパレータ集合となる.\\
$|V(H)|\leq (\alpha + \varepsilon)|V|$の時,反復は終了する.各反復において2つのノード$s,t \in V$を一様ランダムに選択する.\\
選択された$s,t$が隣接しているかまたは$s = t$の時,$H[V(H) \backslash (\{s\} \cup \{t\})]$にあるノード数が一番多い連結成分$C$を計算する.$s,t$が各連結成分のノード数はSAラウンドでそれぞれ計算可能.得られた$C$を$H$として反復を繰り返す.\\
$s,t$が離れているとき,入力を$(H,K,s,t)$として縮約アルゴリズムを実行,得られたカットを$(S,T)$とする.
$H[V(H) \backslash (S \cup T \cup \{s\} \cup \{t\})]$にある頂点数が一番多い連結成分$C$を計算する.各連結成分の頂点数はSAラウンドでそれぞれ計算可能.得られた$C$を$H$として反復を繰り返す.\par
以上の操作により,求めたいセパレータが構成できた.

\section{アルゴリズムの評価}
近似アルゴリズムは,$s,t$を一様ランダムに選択して動作する,ラスベガス法による乱拓アルゴリズムである.\cite{brandt2017approximating}の補題28より,アルゴリズムは高確率で$O(\varepsilon^{-1}K\log^{1+o(1)}n)$回の反復で終了する.各反復において,$S'$のサイズは最大$2K+2$増える.これは,縮約アルゴリズムの結果$(S,T)$とノード$s,t$の個数を意味する.従って,アルゴリズムはサイズ$O(\varepsilon^{-1}K^2\log^{1+o(1)}n)$の$(\alpha + \varepsilon)$セパレータを$\tilde{O}(\varepsilon^{-1}K^3(K^{O(1)}+\ell)(\sqrt{n}+D))$ラウンドで計算できる.

\chapter{研究のまとめ}
本研究では,Subgraph Aggregationタスクを使用して,s-t点素パスを計算分散アルゴリズムを計算するアルゴリズムを繰り返し適用してバランスの取れたカットを探索することによって,サイズ$O(\varepsilon^{-1}K^2\log^{1+o(1)}n)$の$(\alpha + \varepsilon)$セパレータを高確率で$\tilde{O}(\varepsilon^{-1}K^3(K^{O(1)}+\ell)(\sqrt{n}+D))$ラウンドで求めることができた.

\chapter{謝辞}
本研究の機会を与え，数々の御指導を賜りました泉泰介准教授に深く感謝致します．また，本研究を進めるにあたり多くの助言を頂き，様々な御協力を頂きました泉研究室の学生のみなさんに深く感謝致します．

% 参考文献

\bibliography{mizutani_references}

% 付録
%\include{appendix}

\end{document}
